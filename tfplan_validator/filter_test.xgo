package tfplan_validator

import (
	"reflect"
	"testing"

	"github.com/davecgh/go-spew/spew"
	tfjson "github.com/hashicorp/terraform-json"
)

// # local_file.foo will be created
// + resource "local_file" "foo" {
// 		+ content              = "foo!"
// 		+ directory_permission = "0777"
// 		+ file_permission      = "0777"
// 		+ filename             = "./foo.bar"
// 		+ id                   = (known after apply)
// 	}

// Plan: 1 to add, 0 to change, 0 to destroy.

// If we like the results we can create a validator that will only accept plans with this create operation. The validator currently only accepts plans in json format.

// > terraform show -json ./plan > ./plan.json
// > tfplan-validator create ../rules.json ./plan.json

// Created rules file ../rules.json that allows Terraform to perform the following actions:

// - local_file.foo can be created

func readPlansP(paths []string) []*tfjson.Plan {
	if plans, err := readPlans(paths); err != nil {
		panic(err)
	} else {
		return plans
	}
}

func TestAccept(t *testing.T) {
	cases := []struct {
		name     string
		in       []*tfjson.Plan
		expected *PlanFilter
	}{
		{
			name: "empty",
			in:   []*tfjson.Plan{},
			expected: &PlanFilter{
				FormatVersion:  CurrentFormatVersion,
				ResourceFilter: []*ResourceFilter{},
			},
		},
		{
			name: "create",
			in:   readPlansP([]string{"../fixtures/create/plan.json"}),
			expected: &PlanFilter{
				FormatVersion: CurrentFormatVersion,
				ResourceFilter: []*ResourceFilter{
					{
						Address: "local_file.foo",
						AllowedActions: []tfjson.Actions{
							tfjson.Actions{tfjson.ActionCreate},
						},
					},
				},
			},
		},
		{
			name: "create-delete",
			in:   readPlansP([]string{"../fixtures/create-delete/plan.json"}),
			expected: &PlanFilter{
				FormatVersion: CurrentFormatVersion,
				ResourceFilter: []*ResourceFilter{
					{
						Address: "local_file.foo",
						AllowedActions: []tfjson.Actions{
							tfjson.Actions{tfjson.ActionCreate, tfjson.ActionDelete},
						},
					},
				},
			},
		},
		{
			name: "delete",
			in:   readPlansP([]string{"../fixtures/delete/plan.json"}),
			expected: &PlanFilter{
				FormatVersion: CurrentFormatVersion,
				ResourceFilter: []*ResourceFilter{
					{
						Address: "local_file.foo",
						AllowedActions: []tfjson.Actions{
							tfjson.Actions{tfjson.ActionDelete},
						},
					},
				},
			},
		},
		{
			name: "delete-create",
			in:   readPlansP([]string{"../fixtures/delete-create/plan.json"}),
			expected: &PlanFilter{
				FormatVersion: CurrentFormatVersion,
				ResourceFilter: []*ResourceFilter{
					{
						Address: "local_file.foo",
						AllowedActions: []tfjson.Actions{
							tfjson.Actions{tfjson.ActionDelete, tfjson.ActionCreate},
						},
					},
				},
			},
		},
		{
			name: "update",
			in:   readPlansP([]string{"../fixtures/update/plan.json"}),
			expected: &PlanFilter{
				FormatVersion: CurrentFormatVersion,
				ResourceFilter: []*ResourceFilter{
					{
						Address: "local_file.foo",
						AllowedActions: []tfjson.Actions{
							tfjson.Actions{tfjson.ActionUpdate},
						},
					},
				},
			},
		},
	}

	for _, tc := range cases {
		t.Run(tc.name, func(t *testing.T) {
			actual := NewPlanFilter()
			for _, in := range tc.in {
				actual.Accept(in)
			}
			if !reflect.DeepEqual(tc.expected, actual) {
				t.Fatalf("expected:\n\n%s\ngot:\n\n%s\n", spew.Sdump(tc.expected), spew.Sdump(actual))
			}
		})
	}
}

// type ResourceFilter struct {
// 	// The absolute resource address.
// 	Address string `json:"address,omitempty"`

// 	// An identifier used during replacement operations, and can be
// 	// used to identify the exact resource being replaced in state.
// 	DeposedKey string `json:"deposed,omitempty"`

// 	// The action to be carried out by this change.
// 	AllowedActions []tfjson.Actions `json:"allowed_actions"`
// }

// func (rf *ResourceFilter) HasActions(actions *tfjson.Action) {
// 	for _, allowed := range rf.AllowedActions {
// 		if allowed == actions {
// 			return true
// 		}
// 	}
// 	return false
// }
